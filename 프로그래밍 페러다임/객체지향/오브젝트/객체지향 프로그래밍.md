## 객체 지향 프로그래밍

### 객체 지향 프로그래밍을 향해

1. 어떤 객체가 필요한지 고민
2. 독립적인 존재가 아닌 기능 구현을 위한 협력하는 공동체의 일원

### 도메인

도메인은 문제 해결을 위해 사용자가 프로그램을 사용하는 분야

### 자율적인 객체

인터페이스와 구현의 분리 원칙

- 퍼블릭 인터페이스: 외부에서 접근 가능한 부분
- 구현: 외부에서 접근 불가하고 내부에서만 접근 가능

### 객체 지향의 장점

객체 지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다.
> 반환 타입: `Long` -> `Money`

객체는 다른 객체의 인터페이스에 공개된 행동을 요청(메세지 전송)하고, 해당 객체는 자율적으로 처리 후 응답(메세지 수신)한다.

### TEMPLATE METHOD 패턴

```java
public class A {
    private B b;

    // B타입으로 업 케스팅이 가능하면 상관없이 실행 가능 (C, D 가능)
    public void A (B b) {
        this.b = b;
    }

    public void callB() {
        // B타입으로 업 케스팅이 가능하면 상관없이 실행 가능    
        b.call();
    }
}

// 공통 코드가 필요없다면 인터페이스로 대체 가능
abstract class B {
    public void call () {
        abstractMethod();
    }

    abstract public void abstractMethod()
}

public class C extends B {
    public void abstractMethod() {
        // 구현
    }
}

public class D extends B {
    public void abstractMethod() {
        // 구현
    }
}
```

기본적인 알고리즘 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

- 코드의 의존성과 실행 시점의 의존성이 다르며 다를수록 코드는 더 유연해지고 확장 가능하지만 이해가 하기 어렵다. (트레이드 오프)

### 차이에 의한 프로그래밍

부모 클래스에 다른 부분만 추가해서 새로운 클래스로 쉽고 빠르게 만드는 방법 (상속)

### 다형성

A는 B에게 메시지를 전송하지만 실제로 어떤 메소드가 실행될지는 메시지를 수신하는 객체의 클래스가 무엇인지에 따라 갈린다.

- 컴파일 시점과 실행 시점의 의존성이 다를 수 있다.

#### 바인딩 방식

- 실행 시점에 바인딩: 지연 바인딩, 동적 바인딩
- 컴파일 시점에 바인딩: 초기 바인딩, 정적 바인딩

### 추상화의 힘

1. 요구사항의 정책을 높은 수준의 서술, 높은 추상화
2. 설계가 유연해짐

### 합성

다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함하여 재사용하는 방법
