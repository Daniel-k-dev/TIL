## 객체 지향 프로그래밍

### 객체 지향 프로그래밍을 향해

1. 어떤 객체가 필요한지 고민 (행동, 상태)
2. 객체는 기능 구현을 위한 협력하는 공동체의 일원

### 도메인

도메인은 문제 해결을 위해 사용자가 프로그램을 사용하는 분야를 의미한다.

### 자율적인 객체

#### 인터페이스와 구현의 분리 원칙

- **퍼블릭 인터페이스:** 외부에서 접근 가능한 부분(public method)
- **구현:** 내부에서만 접근 가능(private method)

### 객체 지향의 장점

객체 지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다.</br>
> Ex:</br>
> 반환 타입: `Long` -> `Money`

객체는 다른 객체의 인터페이스에 공개된 행동을 요청(메세지 전송)하고, 해당 객체는 자율적으로 처리 후 응답(메세지 수신)한다.

#### TEMPLATE METHOD 패턴

기본적인 알고리즘 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

- 코드의 의존성과 실행 시점의 의존성이 다름
- 다를수록 유연하고 확장 가능하지만 이해가 어려움 (트레이드 오프)

```java
public class A {
    private B b;

    // B타입으로 업 케스팅이 가능하면 상관없이 실행 가능 (C, D 가능)
    public void A (B b) {
        this.b = b;
    }

    public void callB() {
        // B타입으로 업 케스팅이 가능하면 상관없이 실행 가능    
        b.call();
    }
}

// 공통 코드가 필요없다면 추상클래스 대신 인터페이스로 대체 가능
abstract class B {
    public void call () {
        abstractMethod();
    }

    abstract public void abstractMethod()
}

public class C extends B {
    public void abstractMethod() {
        // 구현
    }
}

public class D extends B {
    public void abstractMethod() {
        // 구현
    }
}
```

### 상속과 다형성

#### 차이에 의한 프로그래밍

상속: 부모 클래스에 다른 부분만 추가해서 새로운 클래스로 쉽고 빠르게 만드는 방법

#### 다형성

특정 타입의 인스턴스에게 메시지를 전송할 때, 어떤 메서드가 실행될지는 수신 객체의 클래스에 의존한다.

- 컴파일 시점과 실행 시점의 의존성이 다를 수 있음

> **설명:**</br>
> 클라이언트가 B타입의 객체에 doSomeThing()를 호출한다고 가정하자</br>
>클래스B와 B의 자식 클래스 C가 있고 C는 B의 doSomeThing()을 오버라이드한다.
클라이언트 관점에서 B나 C 둘 중 어느 객체가 doSomeThing()메서드를 실행할지 알 수 없다.
B와 C중 어느 객체가 해당 메서드를 실행하는지는 실행 시점에 알 수 있다.

#### 바인딩 방식

- 실행 시점 바인딩: 지연 바인딩, 동적 바인딩
- 컴파일 시점 바인딩: 초기 바인딩, 정적 바인딩

### 추상화와 유연성

#### 추상화의 힘

- 요구사항의 정책을 높은 수준의 서술, 높은 추상화
- 유연한 설계를 얻음

#### 합성

다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함하여 재사용하는 방법
