## 의존성 관리하기

### 의존성 이해하기

#### 의존성 전이

의존 대상에 대해 자동적인 의존을 의미한다.

> A가 의존하는 B, B가 의존하는 C에 대해 A는 의존성 전파가 발생한다.

- **직접 의존성**
  - 한 요소가 다른 요소에 직접 의존
- **간접 의존성**
  - 의존성 전이에 의한 영향 전파

#### 런타임 의존성과 컴파일 타임 의존성

- **런타임 의존성**
  - 애플리케이션의 실행 시점에 의존성
- **컴파일 타임 의존성**
  - 작성한 코드 구조에서의 의존성

#### 컨텍스트 독립성

컨텍스트 독립성은 다른 문맥에서 재사용의 수월한 정도를 의미한다.

구체적 정보를 적게 알아야 한다. 구체적인 정보를 알수록 결합도가 높아진다.

> 컨텍스트 독립적 이라는 말은 객체가 해당 객체를 실행하는 시스템에 대해 관해 아무것도 알지 못한다는 것이다.

#### 의존성 해결하기

컴파일 시점의 의존성을 실행 시점에서 교체 (컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체)

- 생성자를 통한 의존성 해결
- setter 메서드를 통해 해결
- 메소드 실행 시 인차를 통해 해결

### 유연한 설계

#### 의존성과 결합도

- 의존성: 두 요소 사이의 관계 유무를 설명
- 결합도: 두 요소 사이에 존재하는 의존성의 강도를 상대적으로 표현

##### 의존성

컨텍스트의 독립적인 의존성은 바람직한 의존성이고, 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.

##### 결합도

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정

- 정보를 알수록 두 요소는 강하게 결합(단단한 결합, 강한 결합도)
  - 두 요소 사이의 의존성이 바람직하지 못할 때를 의미
- 적은 정보를 알고 있을수록 두 요소는 약하게 결합(느슨한 결합, 약한 결합도)
  - 어떤 두 요소 사이에 존재하는 의존성이 바람직함을 의미

#### 추상화에 의존하라

추상화: 불필요한 정보 감춤, 알아야하는 지식의 양을 줄여 느슨한 결합 유지 가능

느슨한 결합도를 위해서 구체 클래스보다 인터페이스에 의존한다.

> 구체 클래스 의존성 < 추상 클래스 의존성 < 인터페이스 의존성

#### 명시적인 의존성

결합도의 느슨함을 위해 구체 클래스의 의존성을 제거한다.

- **명시적인 의존성**
  - 모든 경우의 의존성은 명시적으로 퍼블릭 인터페이스에 노출
- **숨겨진 의존성**
  - 클래스 내부에서 다른 인스턴스를 직접 생성하는 것, 의존성은 명시적이여야 함

의존성을 구현 내부에 숨겨두지 마라. 경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것이다.

#### new는 해롭다

- 구체 클래스 의존으로 결합도가 높음
- 지식의 양 증가로 결합도 상승
- 인스턴스 생성을 위한 인자의 정보 필요
- 해당 인자의 순서, 사용에 대한 정보 노출
- 구체 클래스에 대한 의존성 증가

유연한 설계는 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작한다.

#### 표준 클래스에 대한 의존은 해롭지 않다

- 변경될 확률이 거의 없는 클래스라면 의존성 문제가 되지 않음
- Java의 표준 클래스가 이 부류에 해당
- 가능한 추상적인 타입을 사용이 확장 측면에서 유리
