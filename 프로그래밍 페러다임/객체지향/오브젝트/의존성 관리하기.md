## 의존성 전이

- 의존성 전이: 의존하는 대상에 대해서 자동적으로 의존하게 되는 것

A가 의존하는 B, B가 의존하는 C에 대해 A는 의존성 전파가 발생한다.

### 직접 의존성, 간접 의존성

- 직접 의존성: 한 요소가 다른 요소에 직접 의존하는 경우
- 간접 의존성: 직접적인 관계는 존재하지 않지만, 의존성 전이에 의해 영향이 전파되는 경우

## 런타임 의존성과 컴파일 타임 의존성

- 런타임 의존성: 애플리케이션이 실행되는 시점에 의존성.
- 컴파일 타임의 의존성: 우리가 작성한 코드 구조에서의 의존성

## 컨텍스트 독립성

컨텍스트 독립성: 다른문맹게서 재사용이 얼마나 더 수월한지 의미

컨텍스트 독립성은 구체적인 정보를 최대한 적게 알아야 한다. 구체적인 클래스를 알면 알수록 그 클래스가 사용하는 특정한 문맥에 강하게 결합되기 때문이다.

> 컨텍스트 독립적 이라는 말은 객체가 해당 객체를 실행하는 시스템에 대해 관해 아무것도 알지 못한다는 것이다.

## 의존성 해결하기

의존성 해결: 컴파일 시점의 의존성을 실행 시점에서 교체
(컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체)

- 생성자를 통한 의존성 해결
- setter 메서드를 통해 해결
- 메소드 실행 시 인차를 통해 해결

## 의존성과 결합도

### 의존성

컨텍스트의 독립적인 의존성은 바람직한 의존성이고, 특정한 콘텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.

### 결합도

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정

더 많은 정보를 알고 있을수록 두 요소는 강하게 결합(단단한 결합, 강한 결합도)
적은 정보를 알고 있을수록 두 요소는 약하게 결합(느슨한 결합, 약한 결합도)

- 느슨한 결합, 약한 결합도: 어떤 두 요소 사이에 존재하는 의존성이 바람직함을 의미
- 단단한 결합, 강한 결합도: 두 요소 사이의 의존성이 바람직하지 못할 때를 의미

### 의존성 결합성 의미

- 의존성: 두 요소 사이의 관계 유무를 설명
- 결합도: 두 요소 사이에 존재하는 의존성의 강도를 상대적으로 표현

## 추상화에 의존하라

추상화: 불필요한 정보를 감춘다. 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.

결합도를 느슨하게 만들기 위해서는 구체 클래스에서 인터페이스에 의존하도록 만드는 것이 효과적인다.

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성

## 명시적인 의존성

결합도를 느슨하게 만들기 위해서는 구체 클래스에 대한 모든 의존성을 제거해야 한다.

- 명시적인 의존성: 모든 경우의 의존성은 명시적으로 퍼블릭 인터페이스에 노출
- 숨겨진 의존성: 인스턴스를 직접 생성하는 방식은 퍼블릭 인터페이스에 표현되지 않음 의존성은 명시적으로 표현되어야 한다.

의존성을 구현 내부에 숨겨두지 마라. 경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것이다.

## new는 해롭다

- 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
- 지식의 양이 늘어나기 때문에 결합도가 높아진다.

new는 클래스를 구체 클래스에 결합시키는 것만으로 끝나지 않는다.

- 인스턴스 생성을 위한 인자의 정보 필요
- 해당 인자의 순서, 사용에 대한 정보 노출
- 구체 클래스에 대한 의존성 추가

유연한 설계는 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작한다.

## 표준 클래스에 대한 의존은 해롭지 않다

- 변경될 확률이 거의 없는 클래스라면 의존성 문제가 되지 않음
- Java의 표준 클래스가 이 부류에 해당
- 가능한 추상적인 타입을 사용이 확장 측면에서 유리
