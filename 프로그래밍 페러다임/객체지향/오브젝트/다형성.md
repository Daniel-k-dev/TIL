## 다형성

다형성은 많은 형태를 가질 수 있는 능력이다.

상속은 타입 계층을 구조화하기 위해 사용해야 한다. 타입 계층은 OOP에서 다형성의 기반을 제공한다. (클라이언트 관점에서 인스턴스를 동일하게 행동하는 그룹으로 묶기 위함이다.)

- **오버로딩 다형성**
  - 하나의 클래스 안에 동일한 이름의 메서드가 존재
- **강제 다형성**
  - 언어에서 지원하는 동적 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
- **매개 변수 다형성**
  - 인스턴스 변수나 메서드의 매개 변수의 타입을 임의의 타입으로 선언, 사용하는 시점에 구체적인 타입으로 지정하는 방식
- **포함 다형성(서브 타입 다형성)**
  - 메시지가 동일해도 객체의 타입에 따라 실제 수행되는 행동이 달라짐

### 상속의 양면성

상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.

### 업케스팅과 동적 바인딩

동일한 코드에서 서로 다른 클래스에 구현된 메서드를 실행할 수 있다.

- 업케스팅: 부모 클래스 타입으로 선언된 변수의 자식 클래스를 인스턴스로 할당 가능
- 동적 바인딩: 메시지를 수신하는 객체의 타입에 따라 실행되는 메소드가 결정

#### 동적 바인딩

- **정적 바인딩, 초기 바인딩, 컴파일 타임 바인딩**
  - 컴파일 타임에 호출된 함수를 결정하는 방식
- **동적 바인딩, 지연 바인딩**
  - 실행될 메서드를 런타임에 결정하는 방식

### 동적 메서드의 탐색과 다형성

객체 지향 시스템의 실행 메서드 선택 과정

1. 메시지 수신 객체는 자기 자신을 생성한 클래스에서 해당 메시지 탐색
2. 해당 메시지가 없으면 부모 클래스에서 탐색, 찾을 때까지 상속 계층을 탐색
3. 상속 계층의 최상위에도 존재하지 않는다면 예외를 발생

#### self 참조 (this)

self참조 생명 주기

1. 객체가 메시지 수신
2. 컴파일러가 self 임시 참조 변수 생성, 메시지 수신 객체에 바인딩
3. 동적 메서드 탐색은 해당 **self 참조에서 부모 클래스로** 이동 탐색
4. 탐색 종료 시 self 참조를 삭제

#### 동적인 문맥

메시지 수신 객체에 따라 메서드 탐색을 위한 문맥이 동적으로 변경되고 메시지를 수신한 객체를 가리키는 self참조에 의해 동적 문맥이 결정된다.

동일한 코드라도 self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 달라진다.

> self 전송은 자신에게 다시 메시지를 전송하는 것이다. self 참조로부터 탐색을 다시 시작해야 한다.</br>
> super 참조의 의도는 지금 이 클래스의 부모 클래스부터 메서드 탐색을 시작한다.
