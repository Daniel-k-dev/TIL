## 프로시저 추상화, 데이터 추상화

현대적인 프로그래밍 언어를 특정 짓는 두 가지 추상화 메커니즘

- **프로시저 추상화**: 소프트웨어가 무엇을 해야 하는지 추상화(기능 분해, 알고리즘 분해)
- **데이터 추상화**: 소프트웨어가 무엇을 알아야 하는지 추상화
  - 데이터 추상화 중심</br>
타입 추상화 (추상 데이터 타입)</br>
프로시저 추상화 (객체 지향)
  
## 프로시저 추상화와 기능 분해

### 알고리즘 분해, 기능 분해

알고리즘 분해, 기능 분해: 기능을 중심으로 시스템을 분리한다. 추상화의 단위는 프로시저다.

### 프로시저

프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.

프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다.

전통적인 기능 분해 방법은 하향식 접근법을 따른다.

### 하향식 접근법

하향식 접근법이란 시스템을 구성하는 가장 최상위 기능을 정의하고 이 최상위 기능을 좀 더 작은 단위의 하위 기능으로 분해해 나가는 방법을 말한다.

기능 분해의 초점은 하나의 문장으로 표현된 기능을 여러 개 더 작은 기능으로 분해하는 것이다.

기능 분해는 책의 목차를 정리하고 그 안에 내용을 채워 넣는 것과 유사하다.

### 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성되어 있지 않음
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 함
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합
- 함수들의 실행 순서를 고정으로 인한 유연성과 사회 재사용성이 저하
- 데이터 형식이 변경될 경우 파급 효과를 예측할 수 없음

#### 시스템은 하나의 메인 함수로 구성되어 있지 않음

어느 시점에 이르면 유일한 메인 함수라는 개념은 없어지고, 시스템은 여러 개의 동등한 수준의 함수 집합으로 성장한다.

#### 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 함

기존 코드를 수정하는 것은 항상 새로운 버그를 만들어낼 확률을 높인다.

새로운 정상을 추가할 때마다 메인 함수의 내부 구현을 수정할 수 밖에 없다. 빈번한 수정으로 버그 발생 확률이 높아지고 시스템은 변경에 취약해진다.

#### 비즈니스 로직이 사용자 인터페이스와 강하게 결합

- 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분이다.
- 비즈니스 로직은 사용자 인터페이스에 비해 변경이 적게 발생한다.

#### 함수들의 실행 순서를 고정으로 인한 유연성과 사회 재사용성이 저하

하향식 기능 분해는 하나의 함수가 더 작은 함수로 세분화되어 실행 순서를 결정한다.

- 함수들의 실행 순서를 정의하는 시간 제약을 강조됨
- 하향식 설계와 관련된 모든 문제의 원인은 결합도
- 함수의 상위 함수가 강요되는 문맥에 강하게 결합
- 다른 함수들과 시간적으로 강하게 결합

#### 데이터 형식이 변경될 경우 파급 효과를 예측할 수 없음

데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분을 그렇지 않은 부분을 명확하게 분리해야 한다.

- 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 잘 이용
- 정의된 퍼블릭 인터페이스가 의존성 관리의 핵심
- 위 문제를 해결하기 위해 정보 은닉과 모듈이라는 개념을 제시

### 하향식 분해가 유용할 때

하향식 분해는 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임이다.

- 설계가 안정화 이후에 사용 시
- 설계의 다양한 측면을 논리적으로 설명하고 분석할 때
- 알고리즘을 문서화하고 서술할 때

실제로 동작하는 커다란 소프트웨어를 설계하는 데 적합한 방법은 아니다.

## 정보 은닉과 모듈

퍼블릭 인터페이스를 통해서만 접근하고 변경의 방향에 맞춰 시스템을 분해한다.

### 정보 은닉

정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리이다.

정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 하는 것이 핵심이다.

### 모듈

모듈은 서브 프로그램이라기보다는 책임의 할당이다.

모듈과 기능 분해는 상호 배타적인 관계가 아니다. 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.

기능분해는 필요한 기능들을 순차적으로 찾아가는 탐색의 과정, 모듈 분해는 감춰야 하는 비밀을 선택하고 감추는 보존의 과정이다.

모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

- **복잡성**: 복잡한 경우 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다.
추상화할 수 있는 간단한 인터페이스를 제공하여 처리
- **변경 가능성**: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급 효과가 커진다. 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공

비밀이 반드시 데이터일 필요는 없고, 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수 있다.

## 모듈의 장점과 한계

### 장점

모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위이다.

- 모듈 내부에만 영향이 감
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리
- 전역 변수와 전역 함수를 제거함으로써 네임 스페이스 오염을 방지

### 단점

인스턴스의 개념을 제공하지 않는다.

다수의 인스턴스가 존재하는 추상화 메커니즘이 필요하게 된다. 이를 만족시키기 위한 개념이 추상 데이터 타입이다.

프로시저 추상화를 보완하기 위해 데이터 추상화의 개념을 제안한다.

## 클래스

객체 지향은 절차 추상화이다.

- 추상화 타입: 오퍼레이션을 기준 추상화
- 클래스: 타입을 기준으로 절차를 추상화
