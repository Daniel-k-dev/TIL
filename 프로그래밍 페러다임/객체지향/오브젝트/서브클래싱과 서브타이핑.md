## 서브 클래싱과 서브 타이핑

#### 상속의 용도

- 타입 계층의 구현
- 코드 재사용

#### 타입 계층

- 부모 클래스는 자식 클래스에 일반화
- 자식 클래스는 부모 클래스의 특수화

#### 코드 재사용

상속의 목표는 타입 계층 구현이어야 한다.

- 상속은 간단한 선언만으로도 부모 클래스의 코드를 재사용 가능
- 부모, 자식 클래스 간 결합도 상승, 변경하기 어려운 코드

타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체로 인해 확장 가능하고 유연한 설계를 얻을 수 있다.

동일 메시지에 서로 다르게 행동 가능한 다형적인 객체 구현을 위해서 객체 행동을 기반으로 타입 계층을 구성해야 한다.

### 타입

#### 개념 관점 타입

개념 관점에서 타입은 우리가 인지하는 세상 사물의 종류를 의미한다. 개념이나 아이디어를 의미한다.

어떤 대상이 A 타입으로 분류되면 그 대상을 A 타입의 인스턴스라 한다. 타입은 심볼, 내연, 외연으로 구성된다.

- **심볼**: 타입에 이름을 붙인 것.
- **내연**: 타입에 속하는 객체들, 객체들이 가지는 공통적인 속성 행동
- **외연**: 타입에 속하는 객체들의 집합
  
#### 프로그래밍 언어 관점에서의 타입

프로그램 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의한 제약과 규칙이다.

- 타입이 수행될 수 있는 유효한 오퍼레이션(+, -) 집합 정의
- 타입에 수행되는 오퍼레이션(+, -)에 대해 미리 약속된 문맥 제공

적용 가능한 오퍼레이션의 종류와 의미를 정의하고 코드의 의미를 명확하게 전달하며 개발자의 실수를 방지할 수 있다.

#### 객체 지향 패러다임 관점

동일한 퍼블릭 인터페이스를 제공하는 객체는 동일 타입이고 퍼블릭 인터페이스가 객체 타입을 결정한다.

- 공통의 특징을 공유하는 대상들
- 동일한 오퍼레이션을 수행할 수 있는 인스턴스의 집합

객체에게 중요한 것은 행동으로 객체를 바라볼 때 객체가 외부에 제공하는 행동에 초점을 맞춘다.

### 타입 계층

- 슈퍼타입(슈퍼셋): 더 일반적인 타입
- 서브타입(서브셋): 더 특수한 타입

> 일반화는 다른 타입을 완전히 포함, 내포
> 특수화는 다른 타입안에 전체적으로 포함, 완전히 내포

#### 객체 지향 프로그래밍과 타입 계층

- 슈퍼타입: 퍼블릭 인터페이스를 일반화시켜 넓은 의미로 정의
- 서브타입: 퍼블릭 인터페이스를 특수화시켜 구체적이고 좁은 의미로 정의

### 서브 클래싱과 서브 타이핑

타입 계층을 구현하는 일반적인 방법은 상속, 상속의 올바른 용도는 타입 계층 구현이다.

#### 언제 상속을 사용해야 하는가?

- 상속 관계가 is-a 관계(슈퍼 타입과 서브 타입 관계에서 is-a보다 행동 호환성이 중요하다.)
- 클라이언트 관점에서 부모 클래스 타입으로 자식 클래스 사용 가능 (행동 호환성)

#### 행동 호환성

행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성이다.

행동의 연관 여부는 클라이언트 관점에서 두 타입이 동일하게 행동한다고 기대되면 같은 타입 계층으로 묶을 수 있다. 행동의 연관성이 없다면 is-a를 사용하지 말아야 한다.

#### 클라이언트의 기대에 따라 계층 분리하기

- 클라이언트에 따라 인터페이스를 분리
- 인터페이스 분리 원칙을 따름
  - 인터페이스를 클라이언트의 기대에 따라 분리하여 영향을 제어하는 설계 원칙
  - 비대한 인터페이스의 단점을 해결

#### 서브 클래싱 서브 타이핑

서브 타이핑을 위해서는 행동 호환성을 만족시켜야 하고 모든 문맥에서 동일하게 행동 가능해야 한다.

- 서브 클래싱
  - 코드 재사용 목적
  - 부모, 자식 클래스 간 행동이 호환되지 않아 인스턴스 교체 불가
  - 서브 클래싱을 구현, 상속 또는 클래스 상속
- 서브 타이핑
  - 자식 클래스와 부모 클래스의 행동의 호환, 대체 가능
  - 서브 타이핑을 인스턴스 상속이라 함

### 리스코프 치환 원칙

리스코프 치환 원칙은 앞에서 말한 행동 호환성을 설계 원칙으로 정리한 것이다.

#### 클라이언트와 대체 가능성

리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다.

#### is-a의 관계 다시 보기

is-a의 관계는 클라이언트 관점에서 is-a일 때만 참이다.
상속이 서브 타이핑을 위해 사용될 경우에만 is-a의 관계이다.
