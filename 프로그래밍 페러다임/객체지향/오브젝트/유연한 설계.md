## 개방-폐쇄 원칙

개방-폐쇄 원칙은 확장에 열려 있어야 하고 수정에는 닫혀 있어야 한다.

- 새로운 동작을 추가해서 어플리케이션의 기능을 확장
- 기존의 코드를 수정하지 않고 어플리케이션의 동작을 추가, 변경

### 컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라

개방-폐쇄의 원칙은 런타임 의존성과 컴파일 타임 의존성에 관한 이야기다.

의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일 타임 의존성을 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.

### 추상화가 핵심이다

개방 폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.

## 생성 사용 분리

객체에 대한 생성과 사용을 분리해야 한다. 유연하고 재사용 가능한 설계를 위해서는 두 가지 책임을 서로 다른 객체로 분리해야한다. 하나는 객체를 생성하는 것이고 다른 하나는 객체를 객체를 사용하는 것이다.

> 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 연결하는) 시작 단계와 실행 단계를 분리해야 한다.

가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.

### 순수한 가공물에게 책임 할당하기

시스템을 객체로 분해하는 데 표면적 분해와 행위적 분해가 있다.

### 표면적 분해

표면적 분해는 도메인에 존재하는 사물 또는 개념을 표현하는 객체이고, 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.

### 행위적 분해

PURE FABRICATION: 도메인과 무관한 인공적인 객체이지만 책임을 할당하기 위한 객체

어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 PURE FABRICATION을 추가하고 이 객체에게 책임을 할당한다.

PURE FABRICATION은 보통 특정한 행동을 표현하는 것이 일반적이다. 표면적 분해보다 행위적 분해에 의해 생성되는 것이 일반적이다.

1. 도메인의 본질적인 개념을 표현하는 추상화를 이용해 어플리케이션을 구축
2. 만약 도메인 개념이 만족스러 못하다면 주저하지 말고 인공적인 객체를 창조

## 의존성 주입

의존성 주입은 외부의 독립적인 객체와 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법이다.

의존성을 해결하는 세 가지 방법은 생성자 주입, setter 주입, 메소드 주입이 있다.

### setter 주입

setter 주입의 장점은 의존성의 대상을 런타임에 변경할 수 있다.

setter 주입의 단점은 객체가 생성된 후에 호출되기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성된다.

### 메소드 주입

메소드 주입은 메소드 호출 주입이라고도 부르며 메소드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있다.

## 숨겨진 의존성은 나쁘다

의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재한다. 그중에서 가장 널리 사용되는 방법은 SERVICE LOCATOR 패턴이다.

SERVICE LOCATOR는 의존성을 해결할 객체들을 보관하는 일종의 저장소이다. 하지만 의존성을 감추게 된다.

실행 시점에서 문제가 발견되고 캡슐화를 위반하기 때문에 명시적인 의존성이 숨겨진 의존성보다 좋다

## 의존성 역전 원칙

의존성 역전 원칙은 상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존해서는 안 된다.

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

전통적인 패러다임에서는 상위 수준 모듈이 하위 수준 모듈에 의존했다면, 객체 지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈이 모두 추상화에 의존한다.

객체 지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.

## 유연성에 대한 조언

유연한 설계는 객관적으로 설계를 판단하기 어렵게 만든다. 불필요한 유연성은 불필요한 복잡성을 낳는다.
