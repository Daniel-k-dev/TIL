# 메모리

## 지역성

캐시는 지역성을 바탕으로 캐싱합니다.

지역성은 자주 사용하는 데이터로 시간 지역성과 공간 지역성이 있습니다.

### 시간 지역성

시간 지역성은 최근 사용한 데이터 다시 접근하는 특성입니다.

루프문이 있습니다.

### 공간 지역성

공간 지역성은 근처 데이터를 다시 접근하는 특성입니다.

배열등의 자료구조가 있습니다.

## 캐시 매핑

캐시 매핑은 캐시가 히트되기 위한 방법입니다. CPU 레지스트리와 RAM 사이에 존재합니다.

### 직접 매핑

직접 매핑은 메모리의 내용을 그대로 매칭한다. (순서대로)

### 연관 매핑

연관 매핑은 순서를 일치시키지 않고 관련된 캐시와 메모리를 매핑합니다.

### 집합 연관 매핑

연관 매핑 + 직접 매핑으로 집합으로 나누고 집합 내부는 순서를 일치시킵니다.


## 가상 메모리

가상 메모리는 컴퓨터가 이용 가능한 메모리 자원을 추상화하여 사용자에게 매우 큰 메모리로 보이게 하는 것입니다.

### 가상 주소

가상 주소는 디스크 영역으로 가상적으로 주어진 주소입니다.

### 실제 주소

실제 주소는 RAM의 주소입니다.

## MMU(메모리 관리 장치)

![Alt text](images/%EB%A9%94%EB%AA%A8%EB%A6%AC/mmu.drawio.svg)

MMU(메모리 관리 장치)는 가상 주소를 실제 주소로 변환합니다.

가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스들의 주소 정보가 들어 있습니다. 속도 향상을 위해 TLB라는 라는 캐시를 사용합니다.

### TLB

TLB는 CPU와 메모리 사이에 위치하며 페이지 테이블에 있는 리스트를 캐싱합니다. 페이지 테이블의 리스트를 캐싱함으로써 CPU는 페이지 테이블까지 가지 않아도 됩니다.

## 스와핑

스와핑은 가상 메모리에는 존재하지만 RAM에 존재하지 않는 경우 페이지 폴트가 발생합니다. 당장 사용하지 않는 부분은 디스크로 필요한 내용을 디스크에서 램으로 로드하면서 스와핑이 발생합니다.

## 페이지 폴트

페이지 폴트는 프로세스가 페이지를 요청하였을 때 그 페이지가 RAM에 없는 상황입니다.

페이지 폴트가 발생하면 스와핑이 발생합니다.

## 페이지,프레임

페이지는 가상 메모리에서의 최소 단위이고, 프레임은 실제 메모리에서 최소 단위입니다.

페이지와 프레임의 크기는 같습니다.

## 스레싱

스레싱은 페이지 폴트가 높아 성능 저하가 나타나는 현상입니다.

메모리에 많은 프로세스로 인한 스와핑의 빈도 상승이 주요 원인입니다.
메모리의 많은 프로세스가 왜 문제가 되냐면 각 프로세스의 공간이 적기 때문에 페이지 폴트가 자주 발생하게 됩니다.

증상은 CPU의 이용률이 감소하고 OS는 CPU의 이용률을 높이기 위해 많은 프로세스를 메모리에 올리게 된다. 악순환이 계속 됩니다.

해결 방법에는 하드웨어적 해결 방법과 소프트웨어적 해결 방법이 있습니다.

### 하드웨어적 해결 방법

하드웨어적 해결 방법에는 HDD를 SSD로 변경하거나 메모리의 공간을 늘리는 방법이 있습니다.

### 소프트웨어적 해결 방법

소프트웨어적 해결 방법은 작업 세트를 도입하거나 PFF를 설정하는 방법이 있습니다.

#### 작업 세트

작업 세트는 지역성을 통하여 결정된 페이지의 집합을 만들어 메모리에 미리 로드합니다.

미리 로드함으로써 스와핑 탐색의 비용을 줄일 수 있습니다.

#### PFF(Page Fault Frequency)

PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조정하는 방법으로 상한선과 하한선을 만들어 상한선에 도달하면 페이지를 늘리고 하한선에 도달하면 페이지를 줄입니다.

## 메모리 할당

메모리 할당에는 연속 할당, 불연속 할당이 있습니다.

### 연속 할당

연속 할당은 순서대로 프로세스를 메모리에 할당합니다.

#### 고정 분할

고정 분할은 메모리를 미리 나눕니다.

내부 단편화가 발생합니다.

#### 가변 분할

가변 분할은 프로그램 크기에 맞춥니다.

외부 단편화가 발생합니다. 외부 단편화에는 최초 적합, 최적 적합, 최악 적합이 있습니다.

## 불연속 할당

불연속 할당은 일반적으로 4kb로 나누고 프로그램마다 페이징 테이블을 두어 메모리에 프로그램을 할당합니다.

### 페이징

페이징은 동일 크기 단위를 페이징 동일 크기 단위가 고정되어 있어 관리가 쉽다.

### 세그먼테이션

세그먼테이션은 논리적 단위로 나누게 되고 단위는 세그먼트입니다.

프로세스는 코드, 데이터, 스택, 힙 으로 나누어지는데 코드와 데이터 또는 함수 단위로 나눌 수 있습니다.
공유 보안 측면이 좋으며 홀의 크기가 균일하지 않습니다.

### 페이지드 세그먼테이션

페이지드 세그먼테이션은 1차로 공유나 의미 단위의 세그먼트로 나누고 2차로 세그먼트를 일정한 크기의 페이지로 나눕니다.

## 페이지 교체 알고리즘

페이지 교체 알고리즘은 스와핑 발생을 줄이기 위한 알고리즘입니다.

### 오프라인 알고리즘

오프라인 알고리즘 미래를 예측해서 페이지를 바꾸는 알고리즘 입니다.

사실상 불가능합니다. 성능 비교에 사용되는 알고리즘입니다.

### FIFO

순서대로

### LRU(Least Recentle Used)

참조가 가장 오래된 페이지 교체 각 페이지마다 계수기 스택을 두어야 한다는 문제점이 있다.

### NUR(Not Used Recently)

clock 알고리즘, LRU의 발전형으로 최근 참조된 페이지를 1, 아닌 페이지를 0으로 두고 순회하며 0이면 교체하는 알고리즘입니다.

### LFU(Least Frequency Used)

가장 참조 횟수가 적은 페이지를 교체한다.
