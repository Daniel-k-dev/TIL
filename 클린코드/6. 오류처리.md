## 오류처리 

항상 잘못될 가능성이 존재한다. 문제점은 이러한 오류처리 때문에 프로그램 논리 이해하기 어려울 수 있다.

### 오류코드보다 예외를 사용하라

일일히 오류코드를 잡아내는 것보다 예외를 던지고 한곳에서 잡는게 낫다.

### try-catch-finally 문부터 작성하라

예외가 발생하는 코드는 TDD를 이용하여 예외를 던지게 한 뒤 try-catch에 넣는다.

### 미확인 예외 사용

안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지않다.

확인된 예외의 문제점

- 하위 단계 예외의 변경이 상위 단계 메서드에 영향이 감 (전부 고쳐야함)
- throws 경로에 위치한 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡술화 깨짐(OCP위반)

중요한 라이브러리를 작성한다면 확인된 예외는 유용하다 그러나 일반적인 어플리케이션은 의존성이라는 비용이 이익보다 크다.

### 예외에 의미 제공

오류 메시지에 정보를 담아 예외와 함께 던진다 실패한 연산 이름과 실패 유형도 언급한다.

### 호출자를 고려해 예외 클래스를 정의하라

오류를 정의할때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이다. 호출하는 입장에서 예외를 잘 잡아낼수 있게 설계해야 한다.

일반적으로 오류를 처리하는 방식은 1. 오류를 기록하고 2. 프로그램을 계속 수행해도 좋은지 확인한다.

- 호출하는 라이브러리 API를 감싸면서 새로운 예외를 던진다.(wrapper 클래스, 감싸기 기법)

감싸기 기법은 다음과 같은 장점이 있다.

- 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.
- 다른 라이브러리로 갈아타도 비용이 적다.
- 외부 API대신 테스트 코드를 넣어주는 방법으로 테스트 하기 쉬워진다.
- 특정 업체의 API 설계 방시에 발목잡히지 않는다. -> 프로그램이 사용하기 편리한 API를 설계하면 된다.

### 정상흐름을 정의해라

위 사항을 따르면 예외처리와 비지니스논리가 잘 분리된 코드가 나온다. 괜찮은 방식같지만 때로는 적합하지 않다.

```ts
try {
  const dailyFoodcost = worker.getDailyFoodCost();
  sum += dailyFoodcost
} catch(e: Error) {
  sum += defualtDailyFoodCost();
}
```

위 코드의 try와 catch부분을 보면 결과적으로 sum에 노동자의 하루 직대를 더한다. 그러나 getDailyFoodCost에서 예외 대신 기본 하루 식대를 반환하면 try-catch를 이용할 일이 없어진다.

### null을 반환하지 마라

null을 반환하는 코드는 일거리를 늘리고 호출자에게 문제를 떠넘긴다.

1. 호출자에서 null 체크
2. nullpointexception 발생

해결 방법

- 예외 던지기
- 특수사례 객체 반환(손 쉬운 해결책)

### null을 전달하지 마라

메서드의 인수로 null을 전달하는 방식은 null 반환보다 나쁘다.

해결 방법

- null 체크
- assert 사용

둘 다 문제를 정확하에 해결하지 못한다. null을 인수로 넘기지 않는 정책이 합리적이다.
