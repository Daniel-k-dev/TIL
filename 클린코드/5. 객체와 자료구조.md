## 객체와 자료구조

변수를 private로 만드는 이유는 실수로 객체의 속성을 건드는 것을 막기 위해서다.

### 자료 추상화

객체의 구현을 감추기 위해서는 추상화가 필요하다. 단순 함수 추가로는 구현을 감출 수 없다. 변수를 private로 설정해도 getter/setter를 제공하면 구현을 외부로 노출하는 셈이다.

사용자가 객체 내부 자료를 모른체 자료의 핵심을 다룰 수 있어야 진정한 의미의 클래스이다. 즉 단순 값만 반환 하는 것이 아닌 호출자 입장에서 객체가 해야하는 행동과 반환해야하는 가공된 값을 반환해야 한다.

개발자는 객체가 포함하는 자료를 표현하는 가장 좋은 방법을 심각하게 고민해야 한다. 아무 생각 없이 getter/setter를 추가하는 방법이 가장 나쁘다.

### 자료/객체 비대칭

- **객체**는 내부 자료를 숨긴채 자료를 다루는 함수만 공개한다.
- **자료구조**는 자료를 그대로 공개하고 별다른 함수는 제공하지 않는다.

객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.

### 디미터 법칙

모듈은 자신이 조작하는 객체의 내부 자료를 몰라야 한다는 법칙이다.

디미터 법칙에 대해 클래스 c의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.

- 클래스 c
- f가 생성한 객체
- f 인수로 넘어온 객체
- c 인스턴스 변수에 저장된 객체

#### 기차 충돌

getter함수가 연속적으로 사용된 코드를 말한다.

만약 조회하려는 정보가 자료구조라면 getter사용이 아닌 public으로 열어 함수를 사용하지 않고 호출하는 것이 바람직하다 하지만 자료구조에도 getter/setter를 정의하라 요구하는 프레임워크와 표준(bean)이 존재한다.

#### 잡종 구조

절반은 객체 절반은 자료구로인 구조이다. 자료구조와 객체의 단점만 모아둔 구조이다.

#### 구조체 감추기

기차 충돌과 같은 코드의 함수가 전부 객체를 반환하는 getter라면 수정해야 한다.

getter를 이용하여 하려는 목적이 뭐였는지를 생각하고 이에 맞게 수정해야 한다.(단숞나 조회가 아닌 뭔가를 하라고 해야 한다.)

### 자료 전달 객체

자료 구조체의 형태는 공개 변수만 있고 함수가 없는 클래스로 Data Transfer Object(DTO)이다.

주로 DB 통신 소켓 메시지 구문 분석에 유용하다.

좀 더 일반적인 형태는 빈(bean) 구조이다. 빈은 비공개 변수에 getter/setter로 조작한다.

#### 활성 레코드

활성 레코드는 DTO + 탐색 함수인 자료구조로 DB나 다른소스에서 자료를 직접 변환한 결과다.

이러한 활성 레코드에 메서드를 추가해 사용하게 되면 잡종구조가 탄생하게 되므로 활성 레코드를 자료구조로 취급해 다른 클래스의 내부 자료로 사용하게 해야 한다.
