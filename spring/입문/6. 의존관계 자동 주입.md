## 의존관계 자동 주입

### 의존관계 자동 주입 방법

- 생성자 주입
- 수정자 주입
- 필드 주입
- 일반 메서드 주입

#### 생성자 주입

객체 생성 시점(생성자 함수 호출 시점) 딱 1번만 호출되며 불변이여야 하거나 필수이면 사용한다.

생성자 함수가 1개만 있으면 `@Autowired` 생략이 가능하다.

#### 수정자 주입 (setter 주입)

`@Autowired`를 통해 자동 주입 가능하며 주입 대상이 없으면 오류가 발생하지만 `@Autowired(required = false)`을 통해 주입 대상이 없어도 동작하게 할 수 있다.

자바 빈 프로퍼티 규약에 맞춘 방식이며 선택, 변경이 가능성이 있으면 사용한다.

#### 필드 주입

필드에 바로 주입하는 방식이다.

```java
class A {
    @Autowired private B b
    @Autowired private C c
    @Autowired private D d
}
```

외부에서 변경 불가능해 테스트가 어렵고 DI 프레임워크에 의존적이다. 안티패턴이며 특수한 상황 (스프링 설정 목적, 어플리케이션의 실제 코드와 상관 X)이 아니면 사용하지 말아야 한다.

#### 일반 메서드 주입

잘 사용하지 않는다.

### 옵션처리

주입해야 할 스프링 빈이 없어도 동작하게 하는 방법이다.

- `@Autowired(required=false)` 주입 대상이 없으면 호출이 안된다.
- `@Nullable` 자동 주입할 대상이 없으면 null 주입
- `Optional<>` : 자동 주입할 대상이 없으면 `Optional.empty` 주입

### 생성자 주입을 선택해라!

- 보통 한번 설정하고 의존관계를 바꿔야하는 일이 별로 없음 오히려 불변으로 유지해야하는게 많음
- setter는 누락, 오용의 가능성이 높다. 객체 내부를 변경하게 되고 이는 예측대로 동작하지 않는 문제가 된다. setter 대신 생성자 주입으로 초기 1번 불변으로 만들면 문제가 해결된다.
- setter는 누락해도 컴파일 요류가 발생하지 않지만 생성자 함수는 컴파일 오류가 발생한다.
- final 키워드를 이용해서 생성자 주입을 강제할 수 있다. 컴파일 오류를 발생시키면서 런타임 오류를 방지할 수 있다.

컴파일 오류는 가장 빠르고 좋은 오류다.

### 롬복과 최신 트랜드

대부분이 다 불변이고 필드에 final 키워드를 이용한다. 그래서 생성자 함수에 연결해줘야 한다. -> 반복되는 코드 작성이 늘어난다.

이를 해결하는게 롬북이다. 롬북은 필드 주입처럼 간결하게 사용 가능하다. 클래스에 `@RequiredArgsConstructor`을 붙여주면 final 필드를 모아 생성자을 자동으로 만들어 준다.

```java
@Component
@RequiredArgsConstructor
class A {
    private final B b
    private final C c
    private final D d
}
```

```java
class A {
    private final B b
    private final C c
    private final D d

    public A(B b, C c, D d) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
```

위 두 코드는 컴파일 된 class 파일에서 동일하다.

롬북은 자바의 어노테이션 프로세서를 이용해서 컴파일 시점에 생성자 코드를 자동으로 생성한다.

일반적으로 생성자를 하나 두고 `@Autowired` 생략을 많이하며 롬북을 이용하면 생성자까지 줄일 수 있다.

### 조회 빈이 2개 이상

`@Autowired` 는 타입으로 조회하기 때문에 해당 타입에 맞는 빈이 여러개가 나올 수 있다.

하위 타입으로 지정하면 DIP 위반 + 같은 타입인 빈에 대해 해결이 되지 않는다. 스프링 빈을 수동 등록해서 문제를 해결하는 방법도 있지만 의존 관계 자동 주입에서 해결하는 방법이 있다.
